{"id":"../node_modules/3id-did-provider/lib/keychain.js","dependencies":[{"name":"/home/vitalpointai/projects/space-gems/node_modules/3id-did-provider/lib/keychain.js.map","includedInParent":true,"mtime":1642262883137},{"name":"/home/vitalpointai/projects/space-gems/node_modules/3id-did-provider/src/keychain.ts","includedInParent":true,"mtime":1642262883137},{"name":"/home/vitalpointai/projects/space-gems/package.json","includedInParent":true,"mtime":1642266346920},{"name":"/home/vitalpointai/projects/space-gems/node_modules/3id-did-provider/package.json","includedInParent":true,"mtime":1642262883137},{"name":"/home/vitalpointai/projects/space-gems/node_modules/3id-did-provider/.babelrc","includedInParent":true,"mtime":1642262883137},{"name":"dids","loc":{"line":35,"column":23},"parent":"/home/vitalpointai/projects/space-gems/node_modules/3id-did-provider/lib/keychain.js","resolved":"/home/vitalpointai/projects/space-gems/node_modules/dids/lib/index.js"},{"name":"key-did-provider-ed25519","loc":{"line":36,"column":43},"parent":"/home/vitalpointai/projects/space-gems/node_modules/3id-did-provider/lib/keychain.js","resolved":"/home/vitalpointai/projects/space-gems/node_modules/key-did-provider-ed25519/dist/key-did-provider-ed25519.esm.js"},{"name":"key-did-resolver","loc":{"line":37,"column":51},"parent":"/home/vitalpointai/projects/space-gems/node_modules/3id-did-provider/lib/keychain.js","resolved":"/home/vitalpointai/projects/space-gems/node_modules/key-did-resolver/lib/index.js"},{"name":"./keyring","loc":{"line":38,"column":39},"parent":"/home/vitalpointai/projects/space-gems/node_modules/3id-did-provider/lib/keychain.js","resolved":"/home/vitalpointai/projects/space-gems/node_modules/3id-did-provider/lib/keyring.js"},{"name":"./utils","loc":{"line":39,"column":24},"parent":"/home/vitalpointai/projects/space-gems/node_modules/3id-did-provider/lib/keychain.js","resolved":"/home/vitalpointai/projects/space-gems/node_modules/3id-did-provider/lib/utils.js"}],"generated":{"js":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Keychain = exports.updateAuthEntry = exports.newAuthEntry = void 0;\nconst dids_1 = require(\"dids\");\nconst key_did_provider_ed25519_1 = require(\"key-did-provider-ed25519\");\nconst key_did_resolver_1 = __importDefault(require(\"key-did-resolver\"));\nconst keyring_1 = __importStar(require(\"./keyring\"));\nconst utils_1 = require(\"./utils\");\nfunction decryptAuthId(encrypted, keyring) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!encrypted.jwe)\n            throw new Error('Invalid encrypted block');\n        const decrypted = yield keyring.asymDecryptJWE(encrypted.jwe, utils_1.parseJWEKids(encrypted.jwe));\n        return decrypted.id;\n    });\n}\nconst encrypter = new dids_1.DID({ resolver: key_did_resolver_1.default.getResolver() });\nfunction authSecretToDID(authSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const did = new dids_1.DID({\n            provider: new key_did_provider_ed25519_1.Ed25519Provider(authSecret),\n            resolver: key_did_resolver_1.default.getResolver(),\n        });\n        yield did.authenticate();\n        return did;\n    });\n}\nfunction newAuthEntry(keyring, threeIdDid, authId, authSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const mainKid = `${threeIdDid}#${keyring.getKeyFragment(keyring_1.LATEST, true)}`;\n        const did = yield authSecretToDID(authSecret);\n        const cleartext = { seed: keyring.seed };\n        if (keyring.v03ID)\n            cleartext.v03ID = keyring.v03ID;\n        const resolvedPromises = yield Promise.all([\n            did.createDagJWE(cleartext, [did.id]),\n            keyring.asymEncryptJWE({ id: authId }, mainKid),\n        ]);\n        return {\n            did,\n            mapEntry: {\n                [did.id]: {\n                    data: { jwe: resolvedPromises[0] },\n                    id: { jwe: resolvedPromises[1] },\n                },\n            },\n        };\n    });\n}\nexports.newAuthEntry = newAuthEntry;\nfunction updateAuthEntry(keyring, authEntry, removedAuthIds, threeIdDid, authDid) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const mainKid = `${threeIdDid}#${keyring.getKeyFragment(keyring_1.LATEST, true)}`;\n        const authId = yield decryptAuthId(authEntry.id, keyring);\n        if (removedAuthIds.find((id) => id === authId))\n            return null;\n        const jwes = yield Promise.all([\n            encrypter.createDagJWE({ seed: keyring.seed }, [authDid]),\n            keyring.asymEncryptJWE({ id: authId }, mainKid),\n        ]);\n        return {\n            data: { jwe: jwes[0] },\n            id: { jwe: jwes[1] },\n        };\n    });\n}\nexports.updateAuthEntry = updateAuthEntry;\nfunction rotateKeys(threeIdx, keyring, removedAuthIds) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const version = threeIdx.get3idVersion();\n        yield keyring.generateNewKeys(version);\n        const update3idState = keyring.get3idState();\n        const authMap = threeIdx.getAuthMap();\n        const newAuthMap = {};\n        yield Promise.all(Object.keys(authMap).map((authDid) => __awaiter(this, void 0, void 0, function* () {\n            const entry = yield updateAuthEntry(keyring, authMap[authDid], removedAuthIds, threeIdx.id, authDid);\n            if (entry) {\n                newAuthMap[authDid] = entry;\n            }\n        })));\n        yield threeIdx.rotateKeys(update3idState, keyring.pastSeeds, newAuthMap);\n    });\n}\nclass Keychain {\n    constructor(_keyring, _threeIdx) {\n        this._keyring = _keyring;\n        this._threeIdx = _threeIdx;\n        this._pendingAdds = [];\n        this._pendingRms = [];\n    }\n    list() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.all(Object.values(this._threeIdx.getAuthMap()).map(({ id }) => __awaiter(this, void 0, void 0, function* () {\n                return decryptAuthId(id, this._keyring);\n            })));\n        });\n    }\n    add(authId, authSecret) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._pendingAdds.push({\n                authId,\n                entry: yield newAuthEntry(this._keyring, this._threeIdx.id, authId, authSecret),\n            });\n        });\n    }\n    remove(authId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._pendingRms.push(authId);\n        });\n    }\n    status() {\n        return {\n            clean: !(this._pendingAdds.length + this._pendingRms.length),\n            adding: this._pendingAdds.map((e) => e.authId),\n            removing: this._pendingRms,\n        };\n    }\n    commit() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._pendingAdds.length && !this._pendingRms.length)\n                throw new Error('Nothing to commit');\n            if (Object.keys(this._threeIdx.getAuthMap()).length === 0) {\n                if (this._pendingRms.length)\n                    throw new Error('Can not remove non-existent auth method');\n                if (!this._pendingAdds.length)\n                    throw new Error('Can not add non-existent auth method');\n                yield this._threeIdx.createIDX((_a = this._pendingAdds.pop()) === null || _a === void 0 ? void 0 : _a.entry);\n            }\n            if (this._pendingRms.length) {\n                yield rotateKeys(this._threeIdx, this._keyring, this._pendingRms);\n                this._pendingRms = [];\n            }\n            if (this._pendingAdds.length) {\n                const entries = this._pendingAdds.map((e) => e.entry);\n                this._pendingAdds = [];\n                yield this._threeIdx.addAuthEntries(entries);\n            }\n        });\n    }\n    static load(threeIdx, authSecret, makeTmpProvider) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const did = yield authSecretToDID(authSecret);\n            const authData = yield threeIdx.loadIDX(did.id);\n            if (authData) {\n                if (!((_a = authData.seed) === null || _a === void 0 ? void 0 : _a.jwe))\n                    throw new Error('Unable to find auth data');\n                try {\n                    const decrypted = yield did.decryptDagJWE(authData.seed.jwe);\n                    const keyring = new keyring_1.default(new Uint8Array(decrypted.seed), decrypted.v03ID);\n                    yield keyring.loadPastSeeds(authData.pastSeeds);\n                    if (keyring.v03ID)\n                        yield threeIdx.create3idDoc(keyring.get3idState(true));\n                    return new Keychain(keyring, threeIdx);\n                }\n                catch (e) {\n                    if (e.message === 'Failed to decrypt')\n                        throw new Error('Auth not allowed');\n                    throw e;\n                }\n            }\n            return Keychain.create(threeIdx, makeTmpProvider);\n        });\n    }\n    static loadFromSeed(threeIdx, seed, did, makeTmpProvider) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyring = new keyring_1.default(seed);\n            yield threeIdx.loadAllDocs(did);\n            yield threeIdx.setDIDProvider(makeTmpProvider(keyring, did));\n            return new Keychain(keyring, threeIdx);\n        });\n    }\n    static create(threeIdx, makeTmpProvider, seed, v03ID) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyring = new keyring_1.default(seed, v03ID);\n            const docParams = keyring.get3idState(true);\n            yield threeIdx.setDIDProvider(makeTmpProvider(keyring, docParams.metadata.controllers[0]));\n            yield threeIdx.create3idDoc(docParams);\n            if (v03ID)\n                threeIdx.setV03ID(v03ID);\n            return new Keychain(keyring, threeIdx);\n        });\n    }\n}\nexports.Keychain = Keychain;\n"},"sourceMaps":{"js":{"version":3,"file":"keychain.js","sourceRoot":"","sources":["../src/keychain.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ThreeIDX, AuthEntry, NewAuthEntry, EncData } from './three-idx'\nimport type { DidProvider } from './did-provider'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport KeyResolver from 'key-did-resolver'\nimport Keyring, { LATEST } from './keyring'\nimport { parseJWEKids } from './utils'\n\nasync function decryptAuthId(encrypted: EncData, keyring: Keyring): Promise<string> {\n  if (!encrypted.jwe) throw new Error('Invalid encrypted block')\n  const decrypted = await keyring.asymDecryptJWE(encrypted.jwe, parseJWEKids(encrypted.jwe))\n  return decrypted.id as string\n}\n\nconst encrypter = new DID({ resolver: KeyResolver.getResolver() })\n\nasync function authSecretToDID(authSecret: Uint8Array): Promise<DID> {\n  const did = new DID({\n    provider: new Ed25519Provider(authSecret),\n    resolver: KeyResolver.getResolver(),\n  })\n  await did.authenticate()\n  return did\n}\n\nexport async function newAuthEntry(\n  keyring: Keyring,\n  threeIdDid: string,\n  authId: string,\n  authSecret: Uint8Array\n): Promise<NewAuthEntry> {\n  const mainKid = `${threeIdDid}#${keyring.getKeyFragment(LATEST, true)}`\n  const did = await authSecretToDID(authSecret)\n\n  const cleartext: Record<string, any> = { seed: keyring.seed }\n  // If we have a legacy seed v03ID will be defined\n  if (keyring.v03ID) cleartext.v03ID = keyring.v03ID\n  const resolvedPromises = await Promise.all([\n    did.createDagJWE(cleartext, [did.id]),\n    keyring.asymEncryptJWE({ id: authId }, mainKid),\n  ])\n  return {\n    did,\n    mapEntry: {\n      [did.id]: {\n        data: { jwe: resolvedPromises[0] },\n        id: { jwe: resolvedPromises[1] },\n      },\n    },\n  }\n}\n\nexport async function updateAuthEntry(\n  keyring: Keyring,\n  authEntry: AuthEntry,\n  removedAuthIds: Array<string>,\n  threeIdDid: string,\n  authDid: string\n): Promise<AuthEntry | null> {\n  const mainKid = `${threeIdDid}#${keyring.getKeyFragment(LATEST, true)}`\n  const authId = await decryptAuthId(authEntry.id, keyring)\n  // Return null if auth entry should be removed\n  if (removedAuthIds.find((id) => id === authId)) return null\n  const jwes = await Promise.all([\n    encrypter.createDagJWE({ seed: keyring.seed }, [authDid]),\n    keyring.asymEncryptJWE({ id: authId }, mainKid),\n  ])\n  return {\n    data: { jwe: jwes[0] },\n    id: { jwe: jwes[1] },\n  }\n}\n\nasync function rotateKeys(\n  threeIdx: ThreeIDX,\n  keyring: Keyring,\n  removedAuthIds: Array<string>\n): Promise<void> {\n  const version = threeIdx.get3idVersion()\n  await keyring.generateNewKeys(version)\n  const update3idState = keyring.get3idState()\n  const authMap = threeIdx.getAuthMap()\n  const newAuthMap: Record<string, any> = {}\n  await Promise.all(\n    Object.keys(authMap).map(async (authDid) => {\n      const entry = await updateAuthEntry(\n        keyring,\n        authMap[authDid],\n        removedAuthIds,\n        threeIdx.id,\n        authDid\n      )\n      if (entry) {\n        newAuthMap[authDid] = entry\n      }\n    })\n  )\n  await threeIdx.rotateKeys(update3idState, keyring.pastSeeds, newAuthMap)\n}\n\ninterface PendingAdd {\n  authId: string\n  entry: NewAuthEntry\n}\n\ninterface KeychainStatus {\n  clean: boolean\n  adding: Array<string>\n  removing: Array<string>\n}\n\nexport class Keychain {\n  private _pendingAdds: Array<PendingAdd> = []\n  private _pendingRms: Array<string> = []\n  /**\n   * The Keychain enables adding and removing of authentication methods.\n   */\n  constructor(public _keyring: Keyring, protected _threeIdx: ThreeIDX) {}\n\n  /**\n   * List all current authentication methods.\n   *\n   * @return    {Array<string>}                           A list of authIds.\n   */\n  async list(): Promise<Array<string>> {\n    return Promise.all(\n      Object.values(this._threeIdx.getAuthMap()).map(async ({ id }: AuthEntry): Promise<string> => {\n        return decryptAuthId(id, this._keyring)\n      })\n    )\n  }\n\n  /**\n   * Add a new authentication method (adds to staging).\n   *\n   * @param     {String}            authId          An identifier for the auth method\n   * @param     {Uint8Array}        authSecret      The authSecret to use, should be of sufficient entropy\n   */\n  async add(authId: string, authSecret: Uint8Array): Promise<void> {\n    this._pendingAdds.push({\n      authId,\n      entry: await newAuthEntry(this._keyring, this._threeIdx.id, authId, authSecret),\n    })\n  }\n\n  /**\n   * Remove an authentication method (adds to staging).\n   *\n   * @param     {String}            authId          An identifier for the auth method\n   */\n  async remove(authId: string): Promise<void> { // eslint-disable-line\n    this._pendingRms.push(authId)\n  }\n\n  /**\n   * Show the staging status of the keychain.\n   * Since removing auth methods will rotate the keys of the 3ID its a good idea\n   * to remove multiple auth methods at once if desired. Therefore we introduce\n   * a commit pattern to do multiple updates to the keychain at once.\n   *\n   * @return    {KeychainStatus}                    Object that states the staging status of the keychain\n   */\n  status(): KeychainStatus {\n    return {\n      clean: !(this._pendingAdds.length + this._pendingRms.length),\n      adding: this._pendingAdds.map((e) => e.authId),\n      removing: this._pendingRms,\n    }\n  }\n\n  /**\n   * Commit the staged changes to the keychain.\n   */\n  async commit(): Promise<void> {\n    if (!this._pendingAdds.length && !this._pendingRms.length) throw new Error('Nothing to commit')\n    if (Object.keys(this._threeIdx.getAuthMap()).length === 0) {\n      if (this._pendingRms.length) throw new Error('Can not remove non-existent auth method')\n      if (!this._pendingAdds.length) throw new Error('Can not add non-existent auth method')\n      // Create IDX structure if not present\n      await this._threeIdx.createIDX(this._pendingAdds.pop()?.entry)\n    }\n    if (this._pendingRms.length) {\n      await rotateKeys(this._threeIdx, this._keyring, this._pendingRms)\n      this._pendingRms = []\n    }\n    if (this._pendingAdds.length) {\n      const entries = this._pendingAdds.map((e) => e.entry)\n      this._pendingAdds = []\n      await this._threeIdx.addAuthEntries(entries)\n    }\n  }\n\n  static async load(\n    threeIdx: ThreeIDX,\n    authSecret: Uint8Array,\n    makeTmpProvider: (keyring: Keyring, managementKey: string) => DidProvider\n  ): Promise<Keychain> {\n    const did = await authSecretToDID(authSecret)\n    const authData = await threeIdx.loadIDX(did.id)\n    if (authData) {\n      if (!authData.seed?.jwe) throw new Error('Unable to find auth data')\n      try {\n        const decrypted = await did.decryptDagJWE(authData.seed.jwe)\n        // If we have a legacy seed v03ID will be defined\n        const keyring = new Keyring(new Uint8Array(decrypted.seed), decrypted.v03ID)\n        await keyring.loadPastSeeds(authData.pastSeeds)\n        // We might have the v03ID in the past seeds, if so we need to create the 3ID documents from the keys\n        if (keyring.v03ID) await threeIdx.create3idDoc(keyring.get3idState(true))\n        return new Keychain(keyring, threeIdx)\n      } catch (e) {\n        if (e.message === 'Failed to decrypt') throw new Error('Auth not allowed')\n        throw e\n      }\n    }\n    return Keychain.create(threeIdx, makeTmpProvider)\n  }\n\n  static async loadFromSeed(\n    threeIdx: ThreeIDX,\n    seed: Uint8Array,\n    did: string,\n    makeTmpProvider: (keyring: Keyring, managementKey: string) => DidProvider\n  ): Promise<Keychain> {\n    const keyring = new Keyring(seed)\n    await threeIdx.loadAllDocs(did)\n    await threeIdx.setDIDProvider(makeTmpProvider(keyring, did))\n    return new Keychain(keyring, threeIdx)\n  }\n\n  static async create(\n    threeIdx: ThreeIDX,\n    makeTmpProvider: (keyring: Keyring, managementKey: string) => DidProvider,\n    seed?: Uint8Array,\n    v03ID?: string\n  ): Promise<Keychain> {\n    const keyring = new Keyring(seed, v03ID)\n    const docParams = keyring.get3idState(true)\n    // Temporarily set DID provider to create 3ID document\n    await threeIdx.setDIDProvider(makeTmpProvider(keyring, docParams.metadata.controllers[0]))\n    await threeIdx.create3idDoc(docParams)\n    if (v03ID) threeIdx.setV03ID(v03ID)\n    return new Keychain(keyring, threeIdx)\n  }\n}\n"]}},"error":null,"hash":"4c81e6975152d646411e0368f5e3b9f7","cacheData":{"env":{}}}